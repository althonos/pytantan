import array
import typing
from typing import Optional, Any, Tuple, Union

from scoring_matrices import ScoringMatrix

def default_scoring_matrix(
    protein: bool = False,
    match_score: Optional[float] = None,
    mismatch_cost: Optional[float] = None,
) -> ScoringMatrix: ...

class Alphabet:
    @property
    def letters(self) -> str: ...
    @classmethod
    def dna(cls) -> Alphabet: ...
    @classmethod
    def protein(cls) -> Alphabet: ...
    def __init__(self, letters: str, protein: bool = False) -> None: ...
    def __len__(self) -> int: ...
    def __contains__(self, item: object) -> bool: ...
    def __getitem__(self, item: int) -> str: ...
    def __reduce__(self) -> Tuple[Any]: ...
    def __repr__(self) -> str: ...
    def __str__(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def encode(self, sequence: Union[str, bytes, bytearray, memoryview]) -> bytes: ...
    def decode(self, sequence: Union[bytes, bytearray, memoryview]) -> str: ...
    def encode_into(
        self,
        sequence: Union[str, bytes, bytearray, memoryview],
        encoded: Union[bytearray, memoryview],
    ) -> None: ...
    def decode_into(
        self,
        encoded: Union[bytes, bytearray, memoryview],
        sequence: Union[bytearray, memoryview],
    ) -> None: ...

class LikelihoodMatrix:
    @property
    def alphabet(self) -> Alphabet: ...
    @property
    def scoring_matrix(self) -> ScoringMatrix: ...
    def __init__(self, alphabet: Alphabet, scoring_matrix: ScoringMatrix) -> None: ...

class RepeatFinder:
    @property
    def alphabet(self) -> Alphabet: ...
    @property
    def scoring_matrix(self) -> ScoringMatrix: ...
    @property
    def likelihood_matrix(self) -> LikelihoodMatrix: ...
    def __init__(
        self,
        scoring_matrix: ScoringMatrix,
        *,
        repeat_start: float = 0.005,
        repeat_end: float = 0.05,
        decay: float = 0.9,
        protein: bool = False,
    ) -> None: ...
    def get_probabilities(
        self, sequence: Union[str, bytes, bytearray, memoryview]
    ) -> array.array[float]: ...
    def mask_repeats(
        self,
        sequence: Union[str, bytes, bytearray, memoryview],
        threshold: float = 0.5,
        mask: Optional[str] = None,
    ) -> str: ...
